#!/usr/bin/env python

### http://www.w3.org/Protocols/rfc2616/rfc2616.html   

import asyncore
import socket as skt
import sys
import os
from urlparse import urlparse

class HTTPdownloader():

    def __init__(self, url):

        self.host, self.path, self.port = self.parse_url(url)

        # Create a TCP socket to host at the right port
        self.clientSocket = skt.socket(skt.AF_INET, skt.SOCK_STREAM)
        self.request_str = self.make_request("GET", self.path, {"HOST": self.host, "Connection": "close"})

        # Variable
        self.collectHeader = ""
        self.numberOfDataReceived = 0
        self.servName = sys.argv[-1]
        self.filename = sys.argv[-2]
        self.startResume = 0
        self.infoName = "information.txt"

        # Create a file to receive the data
        # self.f = open(self.filename, 'wb')

        self.canResume()

    def canResume(self):

        if os.path.exists(self.filename):
            self.startResume += os.path.getsize(self.filename) + 1
            self.openSocketForResume()

            # return self.startResume
            # self.openSocketForResume()
            
            # self.makeResume()

            # print self.startResume
        else:
            self.openSocket()
            self.findHeader()

    # def makeResume(self):
    #     # self.Range = "Range: bytes=500-900"
    #     self.Range = "Range: bytes="+"self.startResume"+"-"+"6000000"
        # self.request_resume = self.request_resume(self.host, self.path, self.Range)
    def getInfo(self):
        # print "get me"
        needYou = open('information.txt', 'r')

        self.allContent = needYou.read().split("\r\n")[-1]

    def openSocketForResume(self):
        self.getInfo()

        self.Range = "Range: bytes="+str(self.startResume)+"-"+self.allContent
        # self.Range = "Range: bytes="+self.allContent+"-"+str(self.startResume)
        self.request_resume = self.resume_request(self.host, self.path, self.Range)

# 
        self.clientSocket.connect((self.host, self.port))
        self.clientSocket.send(self.request_resume)

        print "Connected again"

        # data = self.clientSocket.recv(1024)
        # while data:
        #     data = self.clientSocket.recv(1024)
        #     print data
    def writeOfReseum(self):


    def openSocket(self):
        self.clientSocket.connect((self.host, self.port))
        self.clientSocket.send(self.request_str)
        # self.clientSocket.send(self.request_resume)

        print "Connection is ready...."


    def resume_request(self,host, path,range):
        NL = "\r\n"

        header = ("GET {p} HTTP/1.1" + NL + "Host: {h}" +NL+self.Range+NL+"Connection: close"+NL+NL).format(p=self.path, h=self.host)
        print header
        return header


    def make_request(self, req_type, what, details, ver="1.1"):
        #""" Compose an HTTP request """
        NL = "\r\n"
        req_line = "{verb} {w} HTTP/{v}".format(verb=req_type, w=what, v=ver)
        details = ["{name}: {v}".format(name=n,v=v) for (n,v) in details.iteritems()]
        detail_lines = NL.join(details)
        full_request = "".join([req_line, NL, detail_lines, NL, NL])
        return full_request

    def parse_url(self, url, DEFAULT_PORT=80):
        #""" Parse a given url into host, path, and port. Use DEFAULT_PORT (80) if unspecified."""
        parsed_url = urlparse(url)
        host, path, port = (parsed_url.hostname, parsed_url.path, parsed_url.port)
        if not port:
            port = DEFAULT_PORT
        return (host, path, port)

    def findHeader(self):
        data_received = self.clientSocket.recv(1024)
        self.collectHeader += data_received
        self.f = open(self.filename, 'wb')

        if "\r\n\r\n" in self.collectHeader:
            self.header, self.remaining_data = self.collectHeader.split("\r\n\r\n")
            self.f.write(self.remaining_data)
            self.keeper = self.findInfoToCompare(self.header)
            self.findContentLength()

    def writeInfo(self):
        # print 'Write info.txt'
        self.info = open(self.infoName, 'wb')
        self.info.write(str(self.keeper))
        self.info.close()


    def findInfoToCompare(self,header):
        splitHeader = self.header.split()

        if "Last-Modified:" in splitHeader:
            indexOfLastModi = splitHeader.index("Last-Modified:")+1

        if "Connection:" in splitHeader:
            indexOfConnection = splitHeader.index("Connection:")

        lastModi =  "".join(splitHeader[indexOfLastModi:indexOfConnection])

        if "ETag:" in splitHeader:
            indexOfEtag = splitHeader.index("ETag:") + 1
            etag = splitHeader[indexOfEtag]

        if "Content-Length:" in splitHeader:
            indexOfContentlength = splitHeader.index("Content-Length:") + 1
            content = splitHeader[indexOfContentlength]

        # print "Lastmodi:    ",lastModi, "Etag:   " ,etag,"Conten: " ,content

        return lastModi+"\r\n"+etag+"\r\n"+content

    # def writeInfo(self,modi, etag, content):


    def findContentLength(self):
        splitHeader = self.header.split()

        if "Content-Length:" in splitHeader:
            indexOfContentlength = splitHeader.index("Content-Length:") + 1
            self.length = splitHeader[indexOfContentlength]
            self.writeInfo()
            self.writeFileWithContentLength(self.length)
        else:
            self.writeFileWithoutContent()
            closeSocket()

    def closeSocket(self):
        self.f.close()
        self.clientSocket.close()
        print "Done loading"

    def writeFileWithContentLength(self, contentLength):
        self.numberOfDataReceived = len(self.remaining_data)
        self.cwd = os.path.abspath('.') + '/'

        try:
            while self.numberOfDataReceived < int(self.length):
                data_received2 = self.clientSocket.recv(8192)
                self.f.write(data_received2)
                self.numberOfDataReceived += len(data_received2)
            try:
                os.remove(self.cwd+self.infoName)
            except OSError:
                pass
        except KeyboardInterrupt:
            # print "KEY i am doing exception"
            self.f.write(str(self.numberOfDataReceived))

        finally: 
            self.closeSocket()

    def writeFileWithoutContentLength(self):
        data_received3 = self.clientSocket.recv(8192)
        while data_received3:
            self.f.write(data_received3)
            data_received3 = self.clientSocket.recv(8192)
        self.closeSocket()



 
 
servName = sys.argv[-1]
if __name__ == '__main__':
    clients = [HTTPdownloader(servName)]
    asyncore.loop()



