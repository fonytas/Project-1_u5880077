#!/usr/bin/env python

### http://www.w3.org/Protocols/rfc2616/rfc2616.html   


import asyncore
import socket as skt
import sys
import os
from urlparse import urlparse

class HTTPdownloader():

    def __init__(self, url):

        self.host, self.path, self.port = self.parse_url(url)

        # Create a TCP socket to host at the right port
        self.clientSocket = skt.socket(skt.AF_INET, skt.SOCK_STREAM)
        self.request_str = self.make_request("GET", self.path, {"HOST": self.host, "Connection": "close"})

        # Open socket
        self.openSocket()

        # Variable
        self.collectHeader = ""
        self.numberOfDataReceived = 0
        self.servName = sys.argv[-1]
        self.filename = sys.argv[-2]
        self.startResume = 0
        # self.Resumable = false


        # Create a file to receive the data
        # self.f = open(self.filename, 'wb')

        self.canResume()

        # "GET /huge-growing-file HTTP/1.1\r\n"+\"Host: www.example.com\r\n"+\"Range: bytes=XXXX-\r\n"+\"Connection: close\r\n\r\n"


    def canResume(self):

        if os.path.exists(self.filename):
            self.startResume += os.path.getsize(self.filename)
            # print self.startResume
        else:
            self.findHeader()

    def openSocket(self):
        self.clientSocket.connect((self.host, self.port))
        self.clientSocket.send(self.request_str)
        print "Connection is ready...."

    def make_request(self, req_type, what, details, ver="1.1"):
        #""" Compose an HTTP request """
        NL = "\r\n"
        req_line = "{verb} {w} HTTP/{v}".format(verb=req_type, w=what, v=ver)
        details = ["{name}: {v}".format(name=n,v=v) for (n,v) in details.iteritems()]
        detail_lines = NL.join(details)
        full_request = "".join([req_line, NL, detail_lines, NL, NL])
        return full_request

    def parse_url(self, url, DEFAULT_PORT=80):
        #""" Parse a given url into host, path, and port. Use DEFAULT_PORT (80) if unspecified."""
        parsed_url = urlparse(url)
        host, path, port = (parsed_url.hostname, parsed_url.path, parsed_url.port)
        if not port:
            port = DEFAULT_PORT
        return (host, path, port)

    def findHeader(self):
        data_received = self.clientSocket.recv(1024)
        self.collectHeader += data_received
        self.f = open(self.filename, 'wb')


        if "\r\n\r\n" in self.collectHeader:
            self.header, self.remaining_data = self.collectHeader.split("\r\n\r\n")
            self.f.write(self.remaining_data)
            self.findContentLength()

    def findContentLength(self):
        splitHeader = self.header.split()

        if "Content-Length:" in splitHeader:
            indexOfContentlength = splitHeader.index("Content-Length:") + 1
            self.length = splitHeader[indexOfContentlength]
            self.writeFileWithContentLength(self.length)
        else:
            self.writeFileWithoutContent()
            closeSocket()

    def closeSocket(self):
        self.f.close()
        self.clientSocket.close()
        print "Done loading"

    def writeFileWithContentLength(self, contentLength):
        self.numberOfDataReceived = len(self.remaining_data)

        while self.numberOfDataReceived < int(self.length):
            data_received2 = self.clientSocket.recv(8192)
            self.f.write(data_received2)
            self.numberOfDataReceived += len(data_received2)
        self.closeSocket()

    def writeFileWithoutContentLength(self):
        data_received3 = self.clientSocket.recv(8192)
        while data_received3:
            self.f.write(data_received3)
            data_received3 = self.clientSocket.recv(8192)
        closeSocket()

    # def needToResume(self):
        


 
servName = sys.argv[-1]
if __name__ == '__main__':
    clients = [HTTPdownloader(servName)]
    asyncore.loop()



